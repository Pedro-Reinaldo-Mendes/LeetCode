# LeetCode - 153. Find Minimum in Rotated Sorted Array

**Profile:** [PedroRM](https://leetcode.com/u/PedroRM/)

## Performance

- **Runtime:** 0 ms (Beats 100.00%)
- **Memory Usage:** 43.65 MB (Beats 84.13%)

## Complexity Analysis

- **Time Complexity:** $O(\log n)$
  - The algorithm uses a binary search approach, halving the search space in each iteration.
- **Space Complexity:** $O(1)$
  - We use a constant amount of extra space for variables.

## Logic Description

The solution utilizes a binary search algorithm to locate the minimum element in the rotated sorted array.

1.  **Initialization**: We start by assuming `nums[0]` is the minimum. We define our search range from index `1` to `nums.length`.
2.  **Binary Search**:
    - We calculate the middle index `i`.
    - If `nums[i]` is less than the current `min`, we update `min` and narrow our search to the left (`top = i`).
    - Otherwise, we continue searching to the right (`low = i + 1`).
3.  **Result**: The process continues until the search space is exhausted, and the found minimum is returned.

### Solution.java

```java
class Solution {
    public int findMin(int[] nums) {
        int min = nums[0];
        int top = nums.length; // Exclusive
        int low = 1; // Inclusive

        while (top != low) {
            int i = ((top - low) / 2) + low;
            if (nums[i] < min) {
                min = nums[i];
                top = i;
            } else {
                low = i + 1;
            }
        }

        return min;
    }
}
```
