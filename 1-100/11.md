# 11. Container With Most Water

[LeetCode Problem Link](https://leetcode.com/problems/container-with-most-water/)

## Performance

- **Runtime**: 4 ms (Beats 93.38%)
- **Memory**: 77.40 MB (Beats 39.28%)

## Complexity Analysis

- **Time Complexity**: $O(N)$, where $N$ is the length of the array. We use a two-pointer approach that traverses the array at most once.
- **Space Complexity**: $O(1)$. We only use a few constant variables (`l`, `r`, `maxArea`, etc.).

## Approach

The problem asks us to find two lines that, together with the x-axis, form a container, such that the container contains the most water.

1.  **Two Pointers**: We typically initialize two pointers, `l` at the beginning (0) and `r` at the end (`height.length - 1`) of the array.
2.  **Greedy Strategy**:
    -   The area is calculated as `width * height`, where `width = r - l` and `height = min(height[l], height[r])`.
    -   To maximize the area, we want to maximize both width and height.
    -   We start with the maximum width.
    -   At each step, we calculate the current area and update the `maxArea` if the current one is larger.
    -   **Decision**: To potentially find a larger area, we must move one of the pointers inward. Moving the pointer corresponding to the *taller* line won't help (the area is limited by the shorter line, and the width would decrease). Therefore, we always move the pointer corresponding to the **shorter** line inward, hoping to find a taller line that compensates for the reduced width.
3.  **Termination**: We repeat the process until the two pointers meet.


### Solution.java

```java

/**
 * 11. Container With Most Water
 * 
 * https://leetcode.com/problems/container-with-most-water/
 */
class Solution {
    public int maxArea(int[] height) {
        // We create the result variable
        int maxArea = 0;
        
        // We set our pointers
        int l = 0;
        int r = height.length - 1;

        // We calculate the maximum possible area for each possible width
        while (l != r) {
            int width = r - l;
            int bottleneck = (height[l] < height[r]) ? height[l++] : height[r--];
            maxArea = Math.max(width * bottleneck, maxArea);
        }

        return maxArea;
    }
}
```